# Что это?
- мультиплеерная игра Cavetronic
- 2D-игра с видом сбоку про дронов, которые исследуют бесконечные пещеры, пытаясь выбраться на поверхность
- чтобы преодолевать большие расстояния под землей игроку придется бурить дыры в стенах
- чтобы бурить стены, понадобятся инструменты и электричество
- чтобы создавать инструменты, требуется перерабатывать определенные ресурсы
- чтобы создавать электричество, требуется сжигать определенные ресурсы
- добыче ресурсов препятствуют постоянно спавнящиеся противники и хрупкость мира
- геймплейный цикл состоит из следующих повторяющихся итераций
    1) разведки местности,
    2) добычи ресурсов
    3) доставки ресурсов в хабы
    4) переработки ресурсов в инструменты и электричество

## Геймплейные цели игры
- основная цель — добраться до двух точек интереса, расположенных на большом удалении от начальной точки возрождения игрока
- первая точка интереса — поверхность, там игрок узнает о ситуации, которая заставила дронов добывать под землей ресурсы
- вторая точка интереса - ядро планеты, там игрок завершает сюжетную линию, находя специальный предмет и финального босса

## Референсы
- `terraria` — отсюда вид сбоку, пещеры, добыча руды и агрессивные противники с большим спавн рейтом
- `factorio` — отсюда система заводов, логистика ресурсов, автоматизация производства, автоматические дроны

## Особенности игры
- глубокая интеграция физической симуляции
- почти все объекты в игре — физически корректные тела, которые реагируют на внешний мир
- добыча ресурсов — это в буквальном смысле откалывание кусков породы от стен
- транспортировка ресурсов предполагает наличие специального транспорта, который нужно "тянуть за собой"
- переработка ресурсов предполагает физическое помещение ресурса в обрабатывающие механизмы при помощи труб

## Архитектура софта
- Сервер-авторитарная модель
- структура логики - ECS
- сериализация данных для транспортировки — MemoryPack
- Физика - Aether.Physics2D
- рендер - Raylib-cs
- реалтайм-транспорт — Steamworks API / Photon

## Физика
- в серверной системе вызывается Physics.Step(dt) 60 раз в секунду
- в клиентской системе Physics.Step(dt) не вызывается, позиция объекта приходит в ecs через сетевой транспорт и интерполируется в физическую модель

## Мультиплеер
- кол-во игроков — 2–4
- Сервер управляет симуляцией, клиенты получают состояние

## Мир
- Процедурная генерация мира
- Мир бесконечный в ширину и глубину, вверху имеется небольшой слой "поверхности"
- мир представляет собой бесконечные пещеры (тоннели)

### Генерация мира
Генерация работает в несколько этапов:
1. **Noise generation** - FastNoiseLite (OpenSimplex2) генерирует базовый шум
2. **Cellular Automata** - сглаживание шума для создания более органичных форм пещер
3. **Island extraction** - SimpleIslandTracer находит связные solid регионы через flood fill
4. **Contour tracing** - для каждого острова создаётся контур по граничным рёбрам клеток
5. **Contour simplification** - удаление вершин на прямых линиях для оптимизации
6. **Physics bodies** - PhysicsBodyBuilder создаёт статические тела из контуров

**Важно:**
- Используется простой алгоритм обхода рёбер, а не Marching Squares
- Контуры обходятся по периметру островов, избегая артефактов типа "веерообразных линий"
- Каждый связный solid регион = один остров = один физический body

### Визуализация генерации
Файл `Images/full_map.png` содержит 3 кадра слева направо:
1. **Raw noise** - сырой шум (серый + зелёные маркеры solid зон)
2. **Boolean grid** - булева сетка после threshold (white = solid, black = empty)
3. **Smoothed + contours** - сглаженная сетка + зелёные контуры вокруг solid островов

Визуализация используется для отладки генерации - можно видеть все этапы процесса.

## Управление
- TBD

## CODE STYLE C#
- используем var
- используем primary конструкторы (которые прямо в объявлении класса)
- если поле ридонли - инициализируем прямо в месте объявления этого поля(например, ecs-query)
- комментарии только у названия метода или класса

## Графика
- зелено-чёрная графика имитирующая старый терминал
- TBD

## Документация архитектурных решений
- все важные архитектурные решения по подсистемам описываются в папке `docs/`
- каждая подсистема — отдельный файл (например `docs/transport.md`, `docs/serialization.md`, `docs/physics.md`)
- ссылки на эти файлы приведены ниже, чтобы Claude мог подгрузить нужный контекст в начале сессии
- при принятии нового архитектурного решения — обновить соответствующий doc-файл
