# Инструкция для Claude

## Лог сессий
Файл `LAST_SESSION.md` (рядом с этим файлом) хранит лог последней сессии.
**В конце каждой сессии** — обновить `LAST_SESSION.md`: что сделано, какие файлы изменены, открытые задачи и планы на следующую сессию.

---

# Что это?
- мультиплеерная игра Cavetronic
- 2D-игра с видом сбоку про дронов, которые исследуют бесконечные пещеры, пытаясь выбраться на поверхность
- чтобы преодолевать большие расстояния под землей игроку придется бурить дыры в стенах
- чтобы бурить стены, понадобятся инструменты и электричество
- чтобы создавать инструменты, требуется перерабатывать определенные ресурсы
- чтобы создавать электричество, требуется сжигать определенные ресурсы
- добыче ресурсов препятствуют постоянно спавнящиеся противники и хрупкость мира
- геймплейный цикл состоит из следующих повторяющихся итераций
    1) разведки местности,
    2) добычи ресурсов
    3) доставки ресурсов в хабы
    4) переработки ресурсов в инструменты и электричество

## Геймплейные цели игры
- основная цель — добраться до двух точек интереса, расположенных на большом удалении от начальной точки возрождения игрока
- первая точка интереса — поверхность, там игрок узнает о ситуации, которая заставила дронов добывать под землей ресурсы
- вторая точка интереса - ядро планеты, там игрок завершает сюжетную линию, находя специальный предмет и финального босса

## Референсы
- `terraria` — отсюда вид сбоку, пещеры, добыча руды и агрессивные противники с большим спавн рейтом
- `factorio` — отсюда система заводов, логистика ресурсов, автоматизация производства, автоматические дроны

## Особенности игры
- глубокая интеграция физической симуляции
- почти все объекты в игре — физически корректные тела, которые реагируют на внешний мир
- добыча ресурсов — это в буквальном смысле откалывание кусков породы от стен
- транспортировка ресурсов предполагает наличие специального транспорта, который нужно "тянуть за собой"
- переработка ресурсов предполагает физическое помещение ресурса в обрабатывающие механизмы при помощи труб

## CODE STYLE C#
- используем var
- используем primary конструкторы (которые прямо в объявлении класса)
- если поле ридонли - инициализируем прямо в месте объявления этого поля(например, ecs-query)
- в рекорд классах каждое следующей поле на новой строке
- если параметров больше трёх в методах - пишем каждый в новой строке
- !!WARNING!! все блоки должны иметь фигурные скобки, даже если можно написать выражение без фигурных скобок
- все логические блоки отделены переносом строки для повышения читабельности
- используем паттерны вместо булевых операторов по возможности
- !!WARNING!! следим за потреблением внешних переменных внутри кверей (чтобы не создавать копии передаваемой в кверю функций)
- !!WARNING!! не кладём в компоненты ссылочные типы. Если без этого никак - документируем решение в блоке "ИСКЛЮЧЕНИЯ ДЛЯ ССЫЛОЧНЫХ ТИПОВ ВНУТРИ КОМПОНЕНТОВ"

## !!WARNING!! Аллокации в горячих путях

**Правило:** в методах `Tick()` и всём, что из них вызывается в штатном режиме, запрещены `new List<>()`, `new HashSet<>()`, LINQ-операторы (`.Where()`, `.Select()`, `.ToList()`, `.Except()`, `.OrderBy()` и т.д.) и `new T[]`.

**Почему:** каждая аллокация — потенциальный GC-stop-the-world. При 120 FPS даже мелкие объекты накапливаются быстро.

**Паттерны замены:**
- Коллекции, нужные на каждый тик системы → `readonly` поля системы, `Clear()` в начале тика
- Утилитные коллекции в статических helper-классах (`BlueprintGeometry`) → `private static readonly` поля, `Clear()` в начале метода. Безопасно, т.к. игра однопоточная
- LINQ `.Where(...).ToList()` → явный цикл `foreach` с `if`
- LINQ `.Except(...).ToList()` → явный цикл `foreach` с `HashSet.Contains`
- `.ToList()` для передачи в метод → отдельный `List`-буфер + `AddRange`

**Оставшаяся проблема — delegate-объект при каждом Query:**
Даже после устранения DisplayClass каждый `Ecs.Query(in desc, lambda)` создаёт `new DelegateType(this, method)`.
Полный фикс — Arch `InlineQuery` с `IForEach`-структурами (zero-alloc API):
```csharp
struct VertexHoverChecker : IForEach<StableId, BlueprintVertex> {
    public float Cx, Cy, BestDist2;
    public int BestVertexId;
    public void Update(ref StableId id, ref BlueprintVertex v) { ... }
}
var checker = new VertexHoverChecker { Cx = _cx, Cy = _cy, ... };
GameWorld.Ecs.InlineQuery<VertexHoverChecker, StableId, BlueprintVertex>(in _verticesQuery, ref checker);
```
Переход на InlineQuery — следующий шаг после стабилизации архитектуры редактора.

**Что допустимо разово:**
- `mesh.Triangles = newArray` при операциях удаления/добавления (пользовательский клик — редко)
- `EarClipTriangulate` и `SortBoundaryAroundVertex` при удалении вершины
- Создание ECS-сущностей при добавлении вершины/треугольника

## ImGui в системах

`rlImGui.Begin()` / `rlImGui.End()` вынесены в системы. Любая система, стоящая **между** `ImGuiBeginSystem` и `ImGuiEndSystem`, может вызывать `ImGui.*`.

```
CameraEndSystem
ImGuiBeginSystem          ← rlImGui.Begin()
MemoryStatsOverlaySystem  ← диагностика памяти + кнопка GC Gen2
[другие UI-системы]       ← встать сюда
ImGuiEndSystem            ← rlImGui.End()
```

`rlImGui.Setup()` / `rlImGui.Shutdown()` остаются в `Program.cs` — это однократная инициализация, не тик.

## Архитектура софта
- Сервер-авторитарная модель
- структура логики - ECS
- сериализация данных для транспортировки — MemoryPack
- Физика - Aether.Physics2D
- рендер - Raylib-cs
- реалтайм-транспорт — Steamworks API / Photon

## Физика
- в серверной системе вызывается Physics.Step(dt) 60 раз в секунду
- в клиентской системе Physics.Step(dt) не вызывается, позиция объекта приходит в ecs через сетевой транспорт и интерполируется в физическую модель

## Мультиплеер
- кол-во игроков — 2–4
- Сервер управляет симуляцией, клиенты получают состояние

## Мир
- Процедурная генерация мира
- Мир бесконечный в ширину и глубину, вверху имеется небольшой слой "поверхности"
- мир представляет собой бесконечные пещеры (тоннели)

### Генерация мира (ПОДРОБНО)

**Единицы измерения:** 1 клетка grid = 1 метр в мире. Параметр `CellSize` удалён — grid-координаты = мировые координаты.

Генерация chunk'а происходит в `CaveGenerationSystem.GenerateChunk()` через следующие этапы:

#### Этап 1: Генерация шума (NoiseGenerator)
- **Класс:** `NoiseGenerator` использует `FastNoiseLite` (OpenSimplex2)
- **Параметры:** `Seed=12345`, `Frequency=0.02`, `Octaves=4`, `Threshold=0.45`
- **Вход:** координаты chunk'а (chunkX, chunkY), размер grid'а (ChunkSize=64)
- **Выход:** `float[,] rawNoise` — значения от -1 до 1
- **Конвертация:** `grid[x,y] = rawNoise[x,y] < Threshold` → `true` = solid, `false` = empty

#### Этап 2: Сглаживание (Cellular Automata)
- **Класс:** `CellularAutomata.Smooth()`
- **Параметры:** `SmoothIterations=2`, `SolidNeighborThreshold=5`
- **Алгоритм:** Каждая итерация проверяет 8 соседей, если ≥5 solid → клетка становится solid
- **Out-of-bounds:** Границы chunk'а считаются solid (для связности между chunk'ами)

#### Этап 3: Заполнение изолированных пустот
- **Метод:** `CellularAutomata.FillEnclosedVoids()` (включено: `fillIsolatedVoids: true`)
- **Алгоритм:**
  1. Flood fill находит все empty острова (связные пустоты)
  2. Если пустота НЕ касается границ chunk'а → заполняет solid
- **Цель:** Убрать изолированные дырки внутри solid областей
- **Почему критично:** SimpleIslandTracer обходит только внешнюю границу, holes не поддерживаются

#### Этап 4: Извлечение островов (SimpleIslandTracer)
- **Класс:** `SimpleIslandTracer.ExtractIslands(grid)`
- **Возвращает:** `List<IslandData>` где `IslandData(Contour, Cells)`
- **Алгоритм:**
  1. **Flood fill** → `List<(int x, int y)> Cells` (связные solid регионы)
  2. **ExtractContour** → граничные рёбра (сторона клетки, граничащая с empty)
     - Рёбра направлены по часовой стрелке вокруг solid (в y-down)
     - Координаты целочисленные (grid = мировые): `new Vector2(x, y)`, `new Vector2(x+1, y+1)`
  3. **TraceEdgeLoop** → обход рёбер через словарь (O(1) поиск, квантование *1000)
  4. **SimplifyContour** → удаление коллинеарных вершин (cross < 0.001)
- **Публичные методы:**
  - `ExtractContour(cells)` — контур из списка клеток
  - `ExtractContourFromSet(cells, cellSet)` — контур с предвычисленным HashSet

#### Этап 5: Конвертация в мировые координаты
- **Смещение:** `offset = (chunkX * ChunkSize, chunkY * ChunkSize)`
- **Трансформация:** каждая точка контура/шарда += offset

#### Этап 6: Разбиение на осколки (ShardGenerator) — Geometric Voronoi
- **Класс:** `ShardGenerator.CreateShards(islandCells, seed)`
- **Зачем:** Острова состоят из шардов, которые можно будет отломать
- **Алгоритм:**
  1. Генерирует N случайных сайтов внутри острова:
     - `N = islandCells.Count / 100`, clamp [3..20]
     - Seed: `baseSeed + chunkX * 1000 + chunkY`, инкрементируется для каждого острова
  2. **Lloyd's relaxation** (2 итерации):
     - Вычисляет Voronoi-ячейки → обрезает по grid → сдвигает сайт к центроиду ячейки
     - Делает ячейки более равномерными (как медовые соты)
  3. **Вычисление Voronoi-ячеек** через пересечение полуплоскостей:
     - Каждая ячейка = большой прямоугольник (margin = max(w,h) + 100)
     - Обрезается биссектрисой с каждым другим сайтом (Sutherland-Hodgman)
     - Биссектриса: `mid = (siteA + siteB) / 2`, `normal = siteA - siteB`
     - Результат — гарантированно выпуклый полигон
  4. **Обрезка по контуру острова** (`ClipCellWithContour`):
     - Внутренние ячейки (все вершины внутри острова) → возвращаются как есть
     - Граничные ячейки — собираются 3 типа точек:
       - **Voronoi-вершины** внутри острова (`IsInIsland` через grid HashSet)
       - **Контурные вершины** острова, ближайшие к этому сайту (`NearestSiteIdx`)
       - **Точки пересечения** рёбер Voronoi-ячейки с рёбрами контура (`SegSegIntersect`)
     - Дедупликация (dist² < 0.01), сортировка по углу вокруг сайта
- **Результат:**
  - Внутренние границы — гладкие прямые линии (Voronoi-биссектрисы)
  - Внешние границы — повторяют контур острова (все вершины контура задействованы)
  - Соседние шарды делят общие вершины
- **Вспомогательные методы:**
  - `SimpleClipToIsland` — быстрая обрезка для Lloyd's (бинарный поиск, без контура)
  - `IsInIsland(p)` → `cellSet.Contains(Floor(p.X), Floor(p.Y))`

#### Этап 6.5: Постобработка шардов (ChunkGenerator)

После Voronoi-шардинга и shaping'а шарды проходят через цепочку постобработки:

1. **EnsureConvexShards** — разбивает невыпуклые шарды на выпуклые части
   - Итеративный diagonal-split: находит reflex-вершину → проводит диагональ к ближайшей валидной вершине → разрезает полигон на две части → повторяет
   - Валидация диагонали: не пересекает рёбра полигона + midpoint внутри полигона (ray casting)
   - Fallback: Earclip триангуляция из Aether (`Triangulate.ConvexPartition`) для ~5% сложных случаев
   - **Bayazit НЕ используется** — `StackOverflowException` убивает процесс, нельзя поймать через try-catch
   - Декомпозеры Aether (`BayazitDecomposer`, `EarclipDecomposer`) — `internal`, доступ только через `Triangulate.ConvexPartition`

2. **RemoveEnclosedShards** — удаляет шарды, погружённые внутрь большего шарда
   - Для каждой пары (меньший, больший): S-H клиппинг меньшего по большему → площадь пересечения
   - Если `площадь_пересечения / площадь_меньшего >= ShardEnclosedThreshold` → удаляем меньший
   - Параметр: `CaveGenerationConfig.ShardEnclosedThreshold` (по умолчанию 0.2)

3. **FilterRectangles** — удаляет прямоугольные артефакты
   - Полигон считается прямоугольником: ровно 4 вершины + все углы ≈ 90° (|cos| < 0.1)

4. **FilterSmallShards** — удаляет шарды с площадью ниже порога
   - Параметр: `CaveGenerationConfig.MinShardArea` (по умолчанию 4)

#### Этап 7: Создание физических тел (PhysicsBodyBuilder)
- **Класс:** `PhysicsBodyBuilder.CreateBodyFromShard(shard)`
- **Алгоритм:** Все шарды гарантированно выпуклые после EnsureConvexShards → одна фикстура `body.CreatePolygon(vertices, density)` на шард
- **Защита:** skip < 3 вершин, try-catch

#### Этап 8: Визуализация (FullMapVisualizer)
- **SaveFullMap:** `full_map.png` — 5 кадров горизонтально:
  1. **Raw noise** — серый градиент + зелёные маркеры solid (threshold)
  2. **Boolean grid** — чёрный=solid, белый=empty
  3. **Smoothed** — после CA
  4. **Contours** — smoothed + красные линии контуров
  5. **Shards** — smoothed + зелёные линии осколков
- **Масштаб:** 8 пикселей/клетка (64×64 chunk → 512×512 пикселей)

### Классы и файлы генерации

| Файл | Назначение |
|------|-----------|
| `CaveGenerationConfig.cs` | Параметры: Seed, Frequency, Octaves, Threshold, SmoothIterations, ChunkSize, MinShardArea, ShardEnclosedThreshold, Friction, Restitution, Density |
| `NoiseGenerator.cs` | Обёртка над FastNoiseLite |
| `CellularAutomata.cs` | Сглаживание + заполнение изолированных пустот |
| `SimpleIslandTracer.cs` | Flood fill → edge tracing → SimplifyContour. Возвращает `List<IslandData>` |
| `ShardGenerator.cs` | Geometric Voronoi (half-plane intersection) + Lloyd's relaxation + clip to contour |
| `PhysicsBodyBuilder.cs` | Одна выпуклая фикстура на шард |
| `FullMapVisualizer.cs` | 5-кадровая визуализация всех этапов |
| `CaveGenerationSystem.cs` | Координатор: вызывает все этапы для каждого chunk'а |

### Известные проблемы и решения

**1. Bayazit stack overflow**
- `StackOverflowException` — нельзя поймать через try-catch в .NET, убивает процесс
- Падает и на полных контурах, и на шардах
- Решение: свой итеративный diagonal-split + Earclip fallback

**2. Holes не поддерживаются**
- SimpleIslandTracer обходит только внешнюю границу
- Решение: `FillEnclosedVoids` заполняет изолированные пустоты перед извлечением

**3. Seed воспроизводимость**
- Каждый chunk: `Seed + chunkX * 1000 + chunkY`, инкрементируется для каждого острова
- Одинаковый seed → одинаковый мир

### Debug инструменты

```csharp
_visualizer.SaveChunkDebug(chunkX, chunkY);
```
- Создаёт `chunk_X_Y_debug.png` (1024×1024, 16 пикселей/клетка)

**Консольный вывод:**
```
[CA] Kept border void: N cells
[CA] Filled isolated void: N cells
[CA] Total: X voids, filled Y, kept Z
```

## Управление
- Реализован полный цикл: Spawner → Drone → Ghost → Spawner
- Keyboard input → InputSignal → интерпретация по типу контролируемой сущности
- K = тестовое убийство дрона (DroneDeathTestSystem, временная)

## Графика
- зелено-чёрная графика имитирующая старый терминал
- TBD

## Управление игроком и спавн

### Общие положения
- Игрок всегда чем-то управляет на карте
- Над контролируемой сущностью отображается никнейм игрока
- Несколько игроков могут управлять одной сущностью (например, спавнером) → несколько никнеймов
- Управление реализовано через пару компонентов ControlOwner (на игроке) ↔ ControlSubject (на контролируемой сущности)

### Конечный автомат управления

```
[Connect] → Spawner Control (дефолтный спавнер)
                ↓ E (дрон готов в stage)
            Drone Control
                ↓ (дрон уничтожен)
            Ghost Control
                ↓ Space
            Spawner Control (дефолтный спавнер)
```

### Три контекста управления

#### 1. Spawner Control
Игрок управляет спавнером (домиком-заводиком).

| Кнопка | Действие |
|--------|----------|
| W / S | Навигация по списку доступных спавнеров |
| F | Переместиться к выбранному спавнеру (мгновенно, без анимации) |
| Space | Выпустить готового дрона из production в stage (игнорируется, если дрон не готов или stage занята) |
| E | Вселиться в дрона из stage-area |

- Список спавнеров всегда виден при управлении спавнером
- В списке — только активированные спавнеры с уникальными именами

#### 2. Drone Control
Игрок управляет головой дрона.

| Кнопка | Действие |
|--------|----------|
| A / D | Катиться влево / вправо |

- Над головой дрона отображается никнейм игрока

#### 3. Ghost Control
Временная сущность после гибели дрона.

| Кнопка | Действие |
|--------|----------|
| Space | Вернуться к дефолтному спавнеру |

- Создаётся на месте гибели дрона
- Левитирует, без коллизии
- Визуал: полупрозрачная красноватая голова дрона

### Спавнер (домик-заводик)

#### Типы спавнеров
- **Дефолтный** — один на мир, в центре карты, всегда активен, неуничтожим, не требует активации
- **Сгенерированные** — появляются при генерации мира
- **Рукотворные** — построены игроками

#### Двухслотовый конвейер производства

```
[Production-area] --Space--> [Stage-area] --E--> Drone в мире
     (1 мин)                   (ждёт игрока)
```

- Production стартует автоматически, когда production-area пуста
- Время производства: 1 минута
- Space выпускает готового дрона из production в stage (дрон буквально выпадает вниз)
- E — вселиться в дрона из stage-area
- Если stage занята и production завершён → production стоит, новый крафт не начинается
- Максимум: 1 дрон в production + 1 дрон в stage
- Таймер производства рисуется над спавнером
- Гонка: кто первый нажал E — тот забрал дрона

#### Имена спавнеров
- Формат: `"X-Y word1 word2"` (X, Y — координаты чанка)
- word1 из словаря X-координат, word2 из словаря Y-координат
- Рандом из seed мира → воспроизводимые имена
- Уникальность гарантирована: занятые имена хранятся в списке

### Компоненты
- **Player** — маркер игрока
- **ControlOwner** — на сущности игрока, ссылается на контролируемую сущность
- **ControlSubject** — на контролируемой сущности
- **DroneHead** — голова дрона
- **Spawner** — спавнер голов дронов (содержит состояние конвейера: production timer, stage occupied)
- **Ghost** — временная сущность после гибели дрона

### Сценарий первого коннекта
1. При старте мира создаётся дефолтный спавнер (центр карты)
2. Игрок коннектится → создаётся сущность Player + ControlOwner
3. ControlOwner автоматически привязывается к дефолтному спавнеру
4. Игрок видит список спавнеров, управляет спавнером (Space / E / W / S / F)
5. Production дрона стартует автоматически
6. Через 1 минуту дрон готов → игрок жмёт Space (выпуск в stage) → E (вселение)

### Полный флоу: жизненный цикл игрока от коннекта до гибели и обратно

**Мир запускается.** Где-то в центре карты стоит дефолтный спавнер — маленький домик-заводик.
Внутри него уже тикает production: через минуту будет готова первая голова дрона.

**Игрок коннектится.** Создаётся сущность с компонентами Player и ControlOwner. У игрока ещё нет
дрона, поэтому управление автоматически присасывается к дефолтному спавнеру — ControlOwner
указывает на спавнер, спавнер получает ControlSubject. Камера показывает домик-спавнер,
над ним появляется никнейм игрока. Если одновременно подключились двое — над спавнером
будут два никнейма, оба "стоят в очереди за дронами".

**Игрок ждёт дрона.** На экране виден домик-спавнер и таймер производства над ним. Сбоку —
список всех активированных спавнеров с их смешными именами (например, "0-0 crumble cookie").
Игрок может кнопками W/S листать список и нажать F, чтобы мгновенно переключиться на другой
спавнер (камера прыгает туда). Можно нажимать Space сколько угодно — ничего не произойдёт,
пока дрон не будет готов.

**Дрон готов.** Таймер дотикал. Игрок жмёт Space — голова дрона буквально выпадает из
production-area вниз в stage-area. Теперь дрон лежит в stage и ждёт, когда его заберут.
Как только production-area освободилась — автоматически стартует производство следующего дрона.

**Игрок вселяется.** Нажатие E — курсор управления перескакивает с домика-спавнера на голову
дрона. Никнейм перемещается со спавнера на дрона. Теперь A/D катят дрона влево-вправо.
Если второй игрок стоял в очереди на этом же спавнере и тоже нажал E — опоздал, дрон уже
забрали. Придётся ждать следующего (а он уже крафтится).

**Пока игрок катается на дроне,** спавнер продолжает работать. Через минуту в production
будет готов ещё один дрон. Но если никто не нажмёт Space для выпуска, а потом не заберёт
предыдущего из stage — конвейер встанет: максимум один дрон в production + один в stage.
Это естественное ограничение от спама спавна.

**Дрон уничтожен.** Камень упал, враг атаковал — голова дрона аннигилирована. На месте
гибели появляется ghost-сущность: полупрозрачная красноватая голова дрона, левитирует
без коллизии. Управление игрока автоматически переключается на ghost. Единственное
доступное действие — нажать Space, чтобы вернуться к дефолтному спавнеру.

**Возврат к спавнеру.** Игрок жмёт Space на ghost-сущности — ghost уничтожается, управление
возвращается к дефолтному спавнеру. Никнейм снова над домиком. Цикл повторяется: ждём
дрона, выпускаем, вселяемся, играем, гибнем, возвращаемся.

### Архитектура системы управления (ECS)

#### Принцип: раскладка управления = система

Каждый тип контролируемой сущности обслуживается своей ECS-системой. Система — это и есть
"раскладка управления": она читает абстрактные входные сигналы из `ControlOwner.Input` и
интерпретирует их в контексте своего типа сущности. Механизм (контролируемая сущность) через
свою систему решает, когда и на что переключить управление игрока. Это делает паттерн
расширяемым: новый тип контролируемой сущности = новая система.

Примеры переиспользования паттерна:
- Спавнер: E → передать управление на дрона в stage
- Дрон → транспорт: кнопка "прикрепиться" → передать управление на транспорт
- Транспорт: кнопка "отсоединиться" → вернуть управление на дрона
- Любой будущий механизм: определяет свою систему, свои правила интерпретации сигналов

#### Входные сигналы

Единый набор абстрактных сигналов, не привязанных к контексту. Расширяем существующий
`NavigationInput` (или заменяем на `InputSignal`):

```csharp
[Flags]
public enum InputSignal : ulong {
  None     = 0,
  Up       = 1UL << 0,    // W
  Down     = 1UL << 1,    // S
  Left     = 1UL << 2,    // A
  Right    = 1UL << 3,    // D
  Action1  = 1UL << 4,    // Space (выпустить / вернуться)
  Action2  = 1UL << 5,    // E     (вселиться / взаимодействовать)
  Action3  = 1UL << 6,    // F     (переместиться / спец. действие)
}
```

Клиент маппит физические клавиши → `InputSignal` → `ControlOwner.Input` каждый кадр.
Серверные системы читают `Input` и интерпретируют по-своему в зависимости от типа сущности.
Один и тот же `Action1` означает "выпустить дрона" на спавнере и "вернуться к спавнеру" на ghost.

#### Компоненты

```
ControlOwner (на сущности Player)
├── SubjectId: int    — StableId контролируемой сущности
└── Input: ulong      — битовая маска InputSignal (заполняется клиентом каждый кадр)

ControlSubject        — маркер на контролируемой сущности (для быстрых запросов)

StableId              — стабильный int-идентификатор для связи между сущностями
                        (DefaultSpawnerId = 1, игроки от 1000+)

DroneHeadSpawner      — маркер + состояние конвейера спавнера
├── ProductionTimer   — оставшееся время крафта
├── ProductionReady   — дрон готов в production-area
└── StageDroneId      — StableId дрона в stage (0 = пусто)

DroneHead             — маркер головы дрона
Ghost                 — маркер ghost-сущности
```

#### Системы управления

Каждая система работает по единому паттерну:
1. Query `(Player, ControlOwner)` — для каждого игрока
2. По `ControlOwner.SubjectId` найти контролируемую сущность через `StableId`
3. Проверить тип сущности (есть нужный компонент-маркер?)
4. Прочитать `ControlOwner.Input` и выполнить действия
5. При необходимости — изменить `ControlOwner.SubjectId` (передача управления)

```
InputSystem (клиент)
  — читает клавиатуру, пишет InputSignal в ControlOwner.Input

SpawnerControlSystem (сервер)
  — Query (Player, ControlOwner) где SubjectId → DroneHeadSpawner
  — Up/Down     → навигация по списку спавнеров
  — Action3 (F) → SubjectId = выбранный спавнер
  — Action1 (Space) → выпустить дрона из production в stage
  — Action2 (E) → SubjectId = дрон в stage (передача управления)

DroneControlSystem (сервер)
  — Query (Player, ControlOwner) где SubjectId → DroneHead
  — Left/Right → приложить силу к физ. телу дрона

GhostControlSystem (сервер)
  — Query (Player, ControlOwner) где SubjectId → Ghost
  — Action1 (Space) → SubjectId = DefaultSpawnerId, уничтожить ghost

SpawnerProductionSystem (сервер, без привязки к игроку)
  — Query (DroneHeadSpawner) — тикает таймер производства независимо от управления
```

#### Передача управления

Передача управления = запись нового значения в `ControlOwner.SubjectId`. Выполняется
текущей системой управления, у которой уже есть `ref ControlOwner` из query:

```csharp
// Пример: SpawnerControlSystem, игрок нажал E
GameWorld.Ecs.Query(in _playersQuery, (ref ControlOwner owner) => {
  var spawner = FindByStableId<DroneHeadSpawner>(owner.SubjectId);
  if (spawner is null) return;                          // не спавнер — не наш
  if (!owner.Has(InputSignal.Action2)) return;          // E не нажата
  if (spawner.StageDroneId == 0) return;                // stage пуста
  owner.SubjectId = spawner.StageDroneId;               // передача управления
});
```

Тот же паттерн для любого будущего механизма: система проверяет условия → пишет новый SubjectId.

#### Поиск сущности по StableId

`GameWorld` хранит индекс `Dictionary<int, Entity>` для O(1) поиска по StableId.
Обновляется при создании/удалении сущностей с StableId.

```csharp
// В GameWorld:
public Dictionary<int, Entity> EntityIndex { get; } = new();

// Хелпер:
public ref T GetComponent<T>(int stableId) where T : struct
  => ref Ecs.Get<T>(EntityIndex[stableId]);
```

#### Клиентские системы (рендер)

```
NicknameRenderSystem (клиент)
  — Query (Player, ControlOwner) → для каждого найти Position контролируемой сущности
  — Рисовать никнейм над этой позицией

CameraFollowSystem (клиент) [= CameraTargetToPlayerControlSubjectSystem]
  — Для локального игрока: камера следует за Position контролируемой сущности

SpawnerUIRenderSystem (клиент)
  — Если игрок управляет спавнером: рисовать список спавнеров, таймер production
```

### Отложенные фичи (не реализуем сейчас)
- Активация / деактивация спавнеров
- Строительство спавнеров игроками
- Для тестирования: спавнеры добавляются вручную в мир, сразу активны


## Редактор блупринтов

Редактор двойного назначения — для создания префабов сущностей и пользовательских блупринтов.
Реализован как ECS-сущность с маркером `Blueprint`, работает по тем же правилам управления,
что спавнер и дрон (является `ControlSubject`).

### Запуск

`Program.StartBlueprintEditorGameLoop()` — собирает упрощённый мир: один игрок, одна Blueprint-сущность,
три вершины, начальный треугольник.

### UX-правила (реализованы)

**Сцена:**
- Красная точка в (0,0) — виртуальный центр объекта
- Один меш на сцене (нельзя создать второй, нельзя удалить последний треугольник)

**Hover:**
- Вершина: радиус 0.4 ед. → синяя → жёлтая при hover
- Ребро: радиус 0.2 ед., только когда ни одна вершина не заховерена → голубое → оранжевое при hover
- Cursor: серый кружок 0.12 ед. в позиции мыши

**Выделение вершин (LMB press):**
- LMB на вершине → выбрать её (сбросить предыдущее)
- Shift+LMB на другой смежной вершине → добавить в выделение (макс. 2)
- Несмежные вершины выбрать нельзя
- LMB внутри меша → сбросить выделение
- Escape / клик снаружи меша → выделение НЕ сбрасывается

**Перемещение вершины (LMB drag):**
- LMB drag на вершине → тянем её за мышью
- Используется offset-based абсолютное позиционирование: `offset = vertex.pos - cursor.pos` захватывается
  один раз в начале drag, применяется как `vertex.pos = cursor.pos + offset` — идемпотентно,
  не накапливает ошибку при несовпадении тикрейтов
- Если выделено две — тянется только SelectedId2, SelectedId1 остаётся

**Создание треугольника:**
- Выделить 2 смежные вершины → превью следует за курсором (зелёный = валидно, красный = нет)
- LMB в пустой области → новая вершина + новый треугольник
- LMB на третьей существующей вершине → треугольник из трёх существующих вершин
- После создания: выделение сбрасывается

**Удаление вершины (RMB click на вершине):**
- RMB click на вершине → удаляет вершину + все содержащие её треугольники
- Осиротевшие вершины (не входящие в оставшиеся треугольники) удаляются вместе с ECS-сущностями
- Запрет: меш не может деградировать до < 3 вершин

**Удаление ребра (RMB click на ребре):**
- RMB click на ребре (hover ≠ вершина) → удаляет все треугольники, содержащие оба конца ребра
- Осиротевшие вершины удаляются
- Запрет: меш не может деградировать до < 3 вершин
- Приоритет: если вершина заховерена — срабатывает удаление вершины, не ребра

**Камера:**
- RMB drag → панорамирование (Figma-стиль)
- RMB click vs RMB drag различается порогом RmbDragThresholdPx = 4px

### Компоненты

```
Blueprint          — маркер Blueprint-сущности

BlueprintVertex    — вершина меша
├── X, Y: float    — позиция в мировых координатах

BlueprintMesh      — топология и hover-состояние (на Blueprint-сущности)
├── Triangles: int[]   — плоский массив StableId вершин, тройками: [v0,v1,v2, v0,v1,v2, ...]
├── SelectedId1: int   — StableId первой выбранной вершины (0 = нет)
├── SelectedId2: int   — StableId второй выбранной вершины (0 = нет)
├── HoveredVertexId: int — StableId вершины под курсором (0 = нет)
├── HoveredEdgeA: int  — StableId первой вершины ребра под курсором (0 = нет)
└── HoveredEdgeB: int  — StableId второй вершины ребра под курсором (0 = нет)
```

**ИСКЛЮЧЕНИЕ:** `int[] Triangles` — ссылочный тип внутри компонента. Динамический размер меша
требует массива; value-type здесь неприменим.

### Типы инпута (ControlSubjectInput<T>)

| Тип `T` | Ключевые поля | Смысл |
|---------|--------------|-------|
| `CursorInput` | `WorldX, WorldY: float` | Текущая позиция курсора в мире |
| `CursorLeftMoveAction` | `StartX/Y, EndX/Y: float` | LMB зажат; Start = позиция в прошлом тике, End = текущая |
| `CursorRightClickAction` | `WorldX, WorldY: float` | RMB клик (не drag) |
| `ShiftModifier` | — | Маркер: Shift зажат |

### Системы

Порядок выполнения в `StartBlueprintEditorGameLoop`:

| Система | Назначение |
|---------|-----------|
| `InputSystem` | Читает Raylib каждый кадр (RMB latching), флашит в ECS по тикрейту 30 Гц |
| `ControlInputSyncSystem` | Копирует инпуты с Player-сущности на Blueprint-сущность |
| `ControlTransferSystem` | Управляет `ControlSubject` |
| `BlueprintCursorSystem` | Обновляет `HoveredVertexId`, `HoveredEdgeA/B` |
| `BlueprintVertexSelectSystem` | LMB press: выделение, создание треугольника |
| `BlueprintVertexMoveSystem` | LMB drag: перемещение вершины (offset-based) |
| `BlueprintEdgeDeleteSystem` | RMB click на ребре: удаление ребра |
| `BlueprintVertexDeleteSystem` | RMB click на вершине: удаление вершины |
| `CameraSystem` | Базовый update камеры |
| `BlueprintCameraSystem` | RMB drag → панорамирование |
| `CameraStartSystem / CameraEndSystem` | BeginMode2D / EndMode2D |
| `BlueprintRenderSystem` | Рисует меш, вершины, ховеры, превью, курсор |

### Правила валидации

**IsVertexMoveValid** (3 проверки):
1. Движущиеся рёбра не пересекают статичные рёбра (SegmentsIntersect, строгое)
2. Обмотка каждого содержащего треугольника сохраняется: `sign(Side_orig) == sign(Side_new)`,
   иначе вершина "проваливается" через базовое ребро (edge-crossing тест это не ловит)
3. Новая позиция не попадает внутрь чужого треугольника

**IsValidNewVertex** (новая вершина W в пустой области):
1. W не внутри существующего меша
2. Winding: W должна быть на стороне, противоположной третьей вершине любого треугольника,
   разделяющего базовое ребро v1-v2 (`newSide * existingSide < 0`)
3. Рёбра W→v1 и W→v2 не пересекают рёбра меша; каждое ребро проверяется только против рёбер,
   не делящих его endpoint (базовое ребро v1-v2 пропускается)

**IsValidTriangleFromExisting** (три существующих вершины):
- Не проверяет IsInsideMesh — существующая вершина заведомо на границе/внутри меша
- Проверяет: нет дубликата треугольника, winding, edge crossings (аналогично IsValidNewVertex)

**BlueprintEdgeDeleteSystem / BlueprintVertexDeleteSystem:**
- Запрет деградации: `remaining.Count < 3` → отмена операции
- Осиротевшие вершины добавляются в `GameWorld.PendingDestroy`

### Архитектура инпута (важно для мультиплеера)

InputSystem работает по схеме "читаем каждый Raylib-кадр, флашим раз в тик":

```
Raylib frame (120 fps)          Tick gate (30 Hz)
─────────────────────           ──────────────────
• IsMouseButtonPressed/Down     • Потребить _rmbClickLatched
• IsMouseButtonReleased         • SyncPayloadInput → ECS
• Обновить _rmbClickLatched     • _buffer.Playback
• Обновить _rmbMoved
```

**Почему так:** `IsMouseButtonReleased` возвращает `true` только один Raylib-кадр. При тикрейте 30 Гц
и FPS 120 вероятность пропустить событие в накопительном гейте ≈ 75%. Решение: лятчим событие
в `_rmbClickLatched` каждый кадр, потребляем в следующем тике.

**_rmbMoved:** сбрасывается в `false` только при `IsMouseButtonPressed`. Если тик пропустил
кадр с press — `_rmbMoved` остаётся `true` от предыдущего drag'а → все последующие click'и
отвергались бы. Поэтому весь RMB tracking вынесен до аккумулятора.

**Соответствие мультиплеерной модели:** клиент читает Raylib каждый кадр, накапливает события,
отправляет пакет на сервер раз в тик. `_rmbClickLatched` отвечает на вопрос "был ли click
с момента последнего пакета?" — точный аналог client-side accumulation перед отправкой.