# Что это?
- мультиплеерная игра Cavetronic
- 2D-игра с видом сбоку про дронов, которые исследуют бесконечные пещеры, пытаясь выбраться на поверхность
- чтобы преодолевать большие расстояния под землей игроку придется бурить дыры в стенах
- чтобы бурить стены, понадобятся инструменты и электричество
- чтобы создавать инструменты, требуется перерабатывать определенные ресурсы
- чтобы создавать электричество, требуется сжигать определенные ресурсы
- добыче ресурсов препятствуют постоянно спавнящиеся противники и хрупкость мира
- геймплейный цикл состоит из следующих повторяющихся итераций
    1) разведки местности,
    2) добычи ресурсов
    3) доставки ресурсов в хабы
    4) переработки ресурсов в инструменты и электричество

## Геймплейные цели игры
- основная цель — добраться до двух точек интереса, расположенных на большом удалении от начальной точки возрождения игрока
- первая точка интереса — поверхность, там игрок узнает о ситуации, которая заставила дронов добывать под землей ресурсы
- вторая точка интереса - ядро планеты, там игрок завершает сюжетную линию, находя специальный предмет и финального босса

## Референсы
- `terraria` — отсюда вид сбоку, пещеры, добыча руды и агрессивные противники с большим спавн рейтом
- `factorio` — отсюда система заводов, логистика ресурсов, автоматизация производства, автоматические дроны

## Особенности игры
- глубокая интеграция физической симуляции
- почти все объекты в игре — физически корректные тела, которые реагируют на внешний мир
- добыча ресурсов — это в буквальном смысле откалывание кусков породы от стен
- транспортировка ресурсов предполагает наличие специального транспорта, который нужно "тянуть за собой"
- переработка ресурсов предполагает физическое помещение ресурса в обрабатывающие механизмы при помощи труб

## Архитектура софта
- Сервер-авторитарная модель
- структура логики - ECS
- сериализация данных для транспортировки — MemoryPack
- Физика - Aether.Physics2D
- рендер - Raylib-cs
- реалтайм-транспорт — Steamworks API / Photon

## Физика
- в серверной системе вызывается Physics.Step(dt) 60 раз в секунду
- в клиентской системе Physics.Step(dt) не вызывается, позиция объекта приходит в ecs через сетевой транспорт и интерполируется в физическую модель

## Мультиплеер
- кол-во игроков — 2–4
- Сервер управляет симуляцией, клиенты получают состояние

## Мир
- Процедурная генерация мира
- Мир бесконечный в ширину и глубину, вверху имеется небольшой слой "поверхности"
- мир представляет собой бесконечные пещеры (тоннели)

### Генерация мира (ПОДРОБНО)

**Единицы измерения:** 1 клетка grid = 1 метр в мире. Параметр `CellSize` удалён — grid-координаты = мировые координаты.

Генерация chunk'а происходит в `CaveGenerationSystem.GenerateChunk()` через следующие этапы:

#### Этап 1: Генерация шума (NoiseGenerator)
- **Класс:** `NoiseGenerator` использует `FastNoiseLite` (OpenSimplex2)
- **Параметры:** `Seed=12345`, `Frequency=0.02`, `Octaves=4`, `Threshold=0.45`
- **Вход:** координаты chunk'а (chunkX, chunkY), размер grid'а (ChunkSize=64)
- **Выход:** `float[,] rawNoise` — значения от -1 до 1
- **Конвертация:** `grid[x,y] = rawNoise[x,y] < Threshold` → `true` = solid, `false` = empty

#### Этап 2: Сглаживание (Cellular Automata)
- **Класс:** `CellularAutomata.Smooth()`
- **Параметры:** `SmoothIterations=2`, `SolidNeighborThreshold=5`
- **Алгоритм:** Каждая итерация проверяет 8 соседей, если ≥5 solid → клетка становится solid
- **Out-of-bounds:** Границы chunk'а считаются solid (для связности между chunk'ами)

#### Этап 3: Заполнение изолированных пустот
- **Метод:** `CellularAutomata.FillEnclosedVoids()` (включено: `fillIsolatedVoids: true`)
- **Алгоритм:**
  1. Flood fill находит все empty острова (связные пустоты)
  2. Если пустота НЕ касается границ chunk'а → заполняет solid
- **Цель:** Убрать изолированные дырки внутри solid областей
- **Почему критично:** SimpleIslandTracer обходит только внешнюю границу, holes не поддерживаются

#### Этап 4: Извлечение островов (SimpleIslandTracer)
- **Класс:** `SimpleIslandTracer.ExtractIslands(grid)`
- **Возвращает:** `List<IslandData>` где `IslandData(Contour, Cells)`
- **Алгоритм:**
  1. **Flood fill** → `List<(int x, int y)> Cells` (связные solid регионы)
  2. **ExtractContour** → граничные рёбра (сторона клетки, граничащая с empty)
     - Рёбра направлены по часовой стрелке вокруг solid (в y-down)
     - Координаты целочисленные (grid = мировые): `new Vector2(x, y)`, `new Vector2(x+1, y+1)`
  3. **TraceEdgeLoop** → обход рёбер через словарь (O(1) поиск, квантование *1000)
  4. **SimplifyContour** → удаление коллинеарных вершин (cross < 0.001)
- **Публичные методы:**
  - `ExtractContour(cells)` — контур из списка клеток
  - `ExtractContourFromSet(cells, cellSet)` — контур с предвычисленным HashSet

#### Этап 5: Конвертация в мировые координаты
- **Смещение:** `offset = (chunkX * ChunkSize, chunkY * ChunkSize)`
- **Трансформация:** каждая точка контура/шарда += offset

#### Этап 6: Разбиение на осколки (ShardGenerator) — Geometric Voronoi
- **Класс:** `ShardGenerator.CreateShards(islandCells, seed)`
- **Зачем:** Острова состоят из шардов, которые можно будет отломать
- **Алгоритм:**
  1. Генерирует N случайных сайтов внутри острова:
     - `N = islandCells.Count / 100`, clamp [3..20]
     - Seed: `baseSeed + chunkX * 1000 + chunkY`, инкрементируется для каждого острова
  2. **Lloyd's relaxation** (2 итерации):
     - Вычисляет Voronoi-ячейки → обрезает по grid → сдвигает сайт к центроиду ячейки
     - Делает ячейки более равномерными (как медовые соты)
  3. **Вычисление Voronoi-ячеек** через пересечение полуплоскостей:
     - Каждая ячейка = большой прямоугольник (margin = max(w,h) + 100)
     - Обрезается биссектрисой с каждым другим сайтом (Sutherland-Hodgman)
     - Биссектриса: `mid = (siteA + siteB) / 2`, `normal = siteA - siteB`
     - Результат — гарантированно выпуклый полигон
  4. **Обрезка по контуру острова** (`ClipCellWithContour`):
     - Внутренние ячейки (все вершины внутри острова) → возвращаются как есть
     - Граничные ячейки — собираются 3 типа точек:
       - **Voronoi-вершины** внутри острова (`IsInIsland` через grid HashSet)
       - **Контурные вершины** острова, ближайшие к этому сайту (`NearestSiteIdx`)
       - **Точки пересечения** рёбер Voronoi-ячейки с рёбрами контура (`SegSegIntersect`)
     - Дедупликация (dist² < 0.01), сортировка по углу вокруг сайта
- **Результат:**
  - Внутренние границы — гладкие прямые линии (Voronoi-биссектрисы)
  - Внешние границы — повторяют контур острова (все вершины контура задействованы)
  - Соседние шарды делят общие вершины
- **Вспомогательные методы:**
  - `SimpleClipToIsland` — быстрая обрезка для Lloyd's (бинарный поиск, без контура)
  - `IsInIsland(p)` → `cellSet.Contains(Floor(p.X), Floor(p.Y))`

#### Этап 6.5: Постобработка шардов (ChunkGenerator)

После Voronoi-шардинга и shaping'а шарды проходят через цепочку постобработки:

1. **EnsureConvexShards** — разбивает невыпуклые шарды на выпуклые части
   - Итеративный diagonal-split: находит reflex-вершину → проводит диагональ к ближайшей валидной вершине → разрезает полигон на две части → повторяет
   - Валидация диагонали: не пересекает рёбра полигона + midpoint внутри полигона (ray casting)
   - Fallback: Earclip триангуляция из Aether (`Triangulate.ConvexPartition`) для ~5% сложных случаев
   - **Bayazit НЕ используется** — `StackOverflowException` убивает процесс, нельзя поймать через try-catch
   - Декомпозеры Aether (`BayazitDecomposer`, `EarclipDecomposer`) — `internal`, доступ только через `Triangulate.ConvexPartition`

2. **RemoveEnclosedShards** — удаляет шарды, погружённые внутрь большего шарда
   - Для каждой пары (меньший, больший): S-H клиппинг меньшего по большему → площадь пересечения
   - Если `площадь_пересечения / площадь_меньшего >= ShardEnclosedThreshold` → удаляем меньший
   - Параметр: `CaveGenerationConfig.ShardEnclosedThreshold` (по умолчанию 0.2)

3. **FilterRectangles** — удаляет прямоугольные артефакты
   - Полигон считается прямоугольником: ровно 4 вершины + все углы ≈ 90° (|cos| < 0.1)

4. **FilterSmallShards** — удаляет шарды с площадью ниже порога
   - Параметр: `CaveGenerationConfig.MinShardArea` (по умолчанию 4)

#### Этап 7: Создание физических тел (PhysicsBodyBuilder)
- **Класс:** `PhysicsBodyBuilder.CreateBodyFromShard(shard)`
- **Алгоритм:** Все шарды гарантированно выпуклые после EnsureConvexShards → одна фикстура `body.CreatePolygon(vertices, density)` на шард
- **Защита:** skip < 3 вершин, try-catch

#### Этап 8: Визуализация (FullMapVisualizer)
- **SaveFullMap:** `full_map.png` — 5 кадров горизонтально:
  1. **Raw noise** — серый градиент + зелёные маркеры solid (threshold)
  2. **Boolean grid** — чёрный=solid, белый=empty
  3. **Smoothed** — после CA
  4. **Contours** — smoothed + красные линии контуров
  5. **Shards** — smoothed + зелёные линии осколков
- **Масштаб:** 8 пикселей/клетка (64×64 chunk → 512×512 пикселей)

### Классы и файлы генерации

| Файл | Назначение |
|------|-----------|
| `CaveGenerationConfig.cs` | Параметры: Seed, Frequency, Octaves, Threshold, SmoothIterations, ChunkSize, MinShardArea, ShardEnclosedThreshold, Friction, Restitution, Density |
| `NoiseGenerator.cs` | Обёртка над FastNoiseLite |
| `CellularAutomata.cs` | Сглаживание + заполнение изолированных пустот |
| `SimpleIslandTracer.cs` | Flood fill → edge tracing → SimplifyContour. Возвращает `List<IslandData>` |
| `ShardGenerator.cs` | Geometric Voronoi (half-plane intersection) + Lloyd's relaxation + clip to contour |
| `PhysicsBodyBuilder.cs` | Одна выпуклая фикстура на шард |
| `FullMapVisualizer.cs` | 5-кадровая визуализация всех этапов |
| `CaveGenerationSystem.cs` | Координатор: вызывает все этапы для каждого chunk'а |

### Известные проблемы и решения

**1. Bayazit stack overflow**
- `StackOverflowException` — нельзя поймать через try-catch в .NET, убивает процесс
- Падает и на полных контурах, и на шардах
- Решение: свой итеративный diagonal-split + Earclip fallback

**2. Holes не поддерживаются**
- SimpleIslandTracer обходит только внешнюю границу
- Решение: `FillEnclosedVoids` заполняет изолированные пустоты перед извлечением

**3. Seed воспроизводимость**
- Каждый chunk: `Seed + chunkX * 1000 + chunkY`, инкрементируется для каждого острова
- Одинаковый seed → одинаковый мир

### Debug инструменты

```csharp
_visualizer.SaveChunkDebug(chunkX, chunkY);
```
- Создаёт `chunk_X_Y_debug.png` (1024×1024, 16 пикселей/клетка)

**Консольный вывод:**
```
[CA] Kept border void: N cells
[CA] Filled isolated void: N cells
[CA] Total: X voids, filled Y, kept Z
```

## Управление
- TBD

## CODE STYLE C#
- используем var
- используем primary конструкторы (которые прямо в объявлении класса)
- если поле ридонли - инициализируем прямо в месте объявления этого поля(например, ecs-query)
- в рекорд классах каждое следующей поле на новой строке
- если параметров больше трёх в методах - пишем каждый в новой строке

## Графика
- зелено-чёрная графика имитирующая старый терминал
- TBD

## Документация архитектурных решений
- все важные архитектурные решения по подсистемам описываются в папке `docs/`
- каждая подсистема — отдельный файл (например `docs/transport.md`, `docs/serialization.md`, `docs/physics.md`)
- ссылки на эти файлы приведены ниже, чтобы Claude мог подгрузить нужный контекст в начале сессии
- при принятии нового архитектурного решения — обновить соответствующий doc-файл
