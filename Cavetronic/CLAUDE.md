# Что это?
- мультиплеерная игра Cavetronic
- 2D-игра с видом сбоку про дронов, которые исследуют бесконечные пещеры, пытаясь выбраться на поверхность
- чтобы преодолевать большие расстояния под землей игроку придется бурить дыры в стенах
- чтобы бурить стены, понадобятся инструменты и электричество
- чтобы создавать инструменты, требуется перерабатывать определенные ресурсы
- чтобы создавать электричество, требуется сжигать определенные ресурсы
- добыче ресурсов препятствуют постоянно спавнящиеся противники и хрупкость мира
- геймплейный цикл состоит из следующих повторяющихся итераций
    1) разведки местности,
    2) добычи ресурсов
    3) доставки ресурсов в хабы
    4) переработки ресурсов в инструменты и электричество

## Геймплейные цели игры
- основная цель — добраться до двух точек интереса, расположенных на большом удалении от начальной точки возрождения игрока
- первая точка интереса — поверхность, там игрок узнает о ситуации, которая заставила дронов добывать под землей ресурсы
- вторая точка интереса - ядро планеты, там игрок завершает сюжетную линию, находя специальный предмет и финального босса

## Референсы
- `terraria` — отсюда вид сбоку, пещеры, добыча руды и агрессивные противники с большим спавн рейтом
- `factorio` — отсюда система заводов, логистика ресурсов, автоматизация производства, автоматические дроны

## Особенности игры
- глубокая интеграция физической симуляции
- почти все объекты в игре — физически корректные тела, которые реагируют на внешний мир
- добыча ресурсов — это в буквальном смысле откалывание кусков породы от стен
- транспортировка ресурсов предполагает наличие специального транспорта, который нужно "тянуть за собой"
- переработка ресурсов предполагает физическое помещение ресурса в обрабатывающие механизмы при помощи труб

## Архитектура софта
- Сервер-авторитарная модель
- структура логики - ECS
- сериализация данных для транспортировки — MemoryPack
- Физика - Aether.Physics2D
- рендер - Raylib-cs
- реалтайм-транспорт — Steamworks API / Photon

## Физика
- в серверной системе вызывается Physics.Step(dt) 60 раз в секунду
- в клиентской системе Physics.Step(dt) не вызывается, позиция объекта приходит в ecs через сетевой транспорт и интерполируется в физическую модель

## Мультиплеер
- кол-во игроков — 2–4
- Сервер управляет симуляцией, клиенты получают состояние

## Мир
- Процедурная генерация мира
- Мир бесконечный в ширину и глубину, вверху имеется небольшой слой "поверхности"
- мир представляет собой бесконечные пещеры (тоннели)

### Генерация мира (ПОДРОБНО)

Генерация chunk'а происходит в `CaveGenerationSystem.GenerateChunk()` через следующие этапы:

#### Этап 1: Генерация шума (NoiseGenerator)
- **Класс:** `NoiseGenerator` использует `FastNoiseLite` (OpenSimplex2)
- **Параметры:** `Seed`, `Frequency`, `Octaves`, `Threshold`
- **Вход:** координаты chunk'а (chunkX, chunkY), размер grid'а
- **Выход:** `float[,] rawNoise` - значения от -1 до 1
- **Конвертация:** `grid[x,y] = rawNoise[x,y] < Threshold` → `true` = solid, `false` = empty

#### Этап 2: Сглаживание (Cellular Automata)
- **Класс:** `CellularAutomata.Smooth()`
- **Параметры:**
  - `SmoothIterations = 2` - количество итераций
  - `SolidNeighborThreshold = 5` - порог для превращения клетки в solid
- **Алгоритм:** Каждая итерация проверяет 8 соседей, если ≥5 solid → клетка становится solid
- **Out-of-bounds:** Границы chunk'а считаются solid (для связности между chunk'ами)
- **Результат:** Более органичные формы пещер

**ВАЖНО: Проблема SmoothIterations**
- `SmoothIterations = 1` - работает нормально
- `SmoothIterations = 2` - может вызывать stack overflow в физике (сложные контуры)
- `SmoothIterations = 4+` - работает (контуры проще)
- Текущее значение: 2 (с защитой от stack overflow)

#### Этап 3: Заполнение пустот
- **Метод:** `CellularAutomata.FillEnclosedVoids()`
- **Включено:** `fillIsolatedVoids: true` в `Smooth()`
- **Алгоритм:**
  1. Flood fill находит все empty острова (связные пустоты)
  2. Для каждой пустоты проверяет, касается ли она границ chunk'а
  3. Если НЕ касается - заполняет (превращает в solid)
  4. Маркирует как посещённые
- **Цель:** Убрать изолированные дырки внутри solid областей

**ВАЖНО: Holes (дырки) не поддерживаются!**
- Контур обходит только внешнюю границу острова
- Если внутри solid есть empty клетки → игнорируются
- Поэтому этап 3 (заполнение пустот) критичен

#### Этап 4: Извлечение островов (SimpleIslandTracer)
- **Класс:** `SimpleIslandTracer.ExtractIslands(smoothedGrid, cellSize)`
- **Возвращает:** `List<IslandData>` где `IslandData(Contour, Cells)` — контур + список клеток
- **Алгоритм:**
  1. **Flood fill** находит все связные solid регионы (острова) → `List<(int x, int y)> Cells`
  2. Для каждого острова создаёт граничные **рёбра** (edges) через `ExtractContour`:
     - Ребро = сторона клетки, которая граничит с empty
     - 4 направления: left, right, top, bottom
     - Рёбра направлены по часовой стрелке вокруг solid (в y-down)
  3. **TraceEdgeLoop** обходит рёбра в правильном порядке:
     - Использует словарь для O(1) поиска следующего ребра (квантование координат)
     - Строит замкнутый контур
  4. **SimplifyContour** удаляет вершины на прямых линиях:
     - Проверяет коллинеарность трёх последовательных точек
     - Если векторное произведение < 0.001 → удаляет среднюю точку
- **Публичные методы для ShardGenerator:**
  - `ExtractContour(cells, cellSize)` — контур из списка клеток
  - `ExtractContourFromSet(cells, cellSet, cellSize)` — контур с предвычисленным HashSet
- **Выход:** `List<IslandData>` — контуры + клетки в локальных координатах chunk'а
- **Единицы:** cellSize (физические единицы)


#### Этап 5: Конвертация в мировые координаты
- **Смещение:** `offset = (chunkX * ChunkSize * CellSize, chunkY * ChunkSize * CellSize)`
- **Трансформация:** `worldIsland = island.Select(p => p + offset)`
- **Результат:** Контуры в мировых координатах

#### Этап 6: Разбиение на осколки (ShardGenerator) — Geometric Voronoi
- **Класс:** `ShardGenerator.CreateShards(islandCells, cellSize, seed)`
- **Зачем:** В физическом мире острова состоят из шардов, которые можно будет отломать от этого острова
- **Алгоритм (Geometric Voronoi через пересечение полуплоскостей):**
  1. Получает список клеток острова из `SimpleIslandTracer` (через `IslandData.Cells`)
  2. Генерирует N случайных точек-сайтов внутри острова (мировые координаты):
     - `N = area / 100` (1 точка на 100 кв.единиц), max 20
     - Seed для воспроизводимости: `baseSeed + chunkX * 1000 + chunkY`
  3. **Lloyd's relaxation** (2 итерации) — сдвигает сайты к центроидам ячеек для равномерности
  4. Вычисляет ячейки Вороного через **пересечение полуплоскостей** (Sutherland-Hodgman):
     - Каждая ячейка начинается как большой прямоугольник
     - Обрезается биссектрисой с каждым другим сайтом (оставляет ближнюю половину)
     - Результат — выпуклый полигон
  5. Обрезает ячейки по границе острова (бинарный поиск пересечения с grid)
- **Результат:** Выпуклые полигоны как медовые соты, соседние шарды делят общие вершины
- **Выход:** `List<List<Vector2>>` - список осколков в локальных координатах chunk'а

**Почему Geometric Voronoi:**
- S-H работает для обрезки выпуклых полигонов полуплоскостями (биссектрисами)
- Каждая ячейка гарантированно выпуклая
- Соседние ячейки делят общие рёбра (биссектрисы)
- Нет ступенчатости — границы шардов это прямые линии

#### Этап 7: Создание физических тел (PhysicsBodyBuilder)
- **Класс:** `PhysicsBodyBuilder.CreateBodyFromShard(shard)`
- **Вход:** Выпуклый осколок (Voronoi ячейка)
- **Алгоритм:**
  1. Вычисляет центр осколка
  2. Создаёт статическое тело в центре
  3. Конвертирует вершины в локальные координаты (относительно центра)
  4. **Fan triangulation** от центроида: разбивает на треугольники (centroid, v[i], v[i+1])
  5. Каждый треугольник → отдельный polygon fixture
  6. Настройки: `Density`, `Friction`, `Restitution`
- **Защита:**
  - Если осколок < 3 вершины → пропускаем
  - Вырожденные треугольники (cross < 0.01) → пропускаем
  - try-catch на случай ошибок физики

**КРИТИЧНО: Bayazit НЕ используется**
- Bayazit рекурсивно триангулирует → stack overflow на сложных контурах
- Fan triangulation не рекурсивен, работает с любым количеством вершин

#### Этап 8: Визуализация (FullMapVisualizer)
- **Метод:** `AddChunk(chunkX, chunkY, rawNoise, grid, smoothedGrid, contours, shards)`
- **Сохраняет:** Все промежуточные данные для каждого chunk'а
- **SaveFullMap:** Создаёт `full_map.png` с 5 кадрами:
  1. **Raw noise** - серый градиент + зелёные маркеры solid зон (threshold)
  2. **Boolean grid** - чёрное (solid), белое (empty) после threshold
  3. **Smoothed** - чёрное (solid), белое (empty) после CA
  4. **Contours** - smoothed grid + красные линии контуров островов
  5. **Shards** - smoothed grid + зелёные линии осколков
- **Масштаб:** 8 пикселей на клетку (64x64 chunk → 512x512 пикселей)
- **Границы:** Красные линии между chunk'ами
- **Цвета:**
  - Чёрный = SOLID (стены)
  - Белый = EMPTY (пещеры)
  - Красный = контуры островов
  - Зелёный = осколки (shards)

### Классы и файлы генерации

- **CaveGenerationConfig.cs** - параметры генерации (Seed, Frequency, SmoothIterations, etc)
- **NoiseGenerator.cs** - обёртка над FastNoiseLite
- **CellularAutomata.cs** - сглаживание + заполнение пустот
- **SimpleIslandTracer.cs** - извлечение контуров островов (flood fill + edge tracing)
- **ShardGenerator.cs** - разбиение островов на осколки (random points)
- **PhysicsBodyBuilder.cs** - создание физических тел из осколков
- **FullMapVisualizer.cs** - визуализация всех этапов (5 кадров)
- **CaveGenerationSystem.cs** - главный класс, координирует все этапы

### Известные проблемы и решения

**1. Stack Overflow в Bayazit триangulation**
- **Причина:** Сложные контуры (>100 вершин) вызывают бесконечную рекурсию
- **Решение:** Разбиение на осколки ДО физики, передача готовых выпуклых полигонов

**2. Holes (дырки) в solid областях**
- **Причина:** SimpleIslandTracer обходит только внешнюю границу, не поддерживает holes
- **Решение:** FillEnclosedVoids заполняет изолированные пустоты (касаются границ → не заполняются)
- **Ограничение:** Большинство пустот касаются границ chunk'а, эффект минимальный

**3. SmoothIterations = 2 vs 1**
- **Проблема:** При 2 итерациях создаются более сложные контуры → больше вершин
- **Решение:** Защита от stack overflow + разбиение на осколки
- **Текущее:** SmoothIterations = 2 работает с защитой

**4. Seed воспроизводимость**
- **Важно:** Каждый chunk использует `Seed + chunkX * 1000 + chunkY` для осколков
- **Результат:** Одинаковый seed → одинаковый мир

### Debug инструменты

**Детальное изображение chunk'а:**
```csharp
_visualizer.SaveChunkDebug(chunkX, chunkY);
```
- Создаёт `chunk_X_Y_debug.png` (1024x1024, 16 пикселей/клетка)
- Красная рамка = границы chunk'а
- Показывает, как пустоты касаются границ

**Консольный вывод:**
```
[CA] Found X voids, filled Y isolated voids
  [CA] Kept border void: N cells
  [CA] Filled isolated void: N cells
[Shards] Skipped complex island: N vertices
```

## Управление
- TBD

## CODE STYLE C#
- используем var
- используем primary конструкторы (которые прямо в объявлении класса)
- если поле ридонли - инициализируем прямо в месте объявления этого поля(например, ecs-query)
- в рекорд классах каждое следующей поле на новой строке
- если параметров больше трёх в методах - пишем каждый в новой строке

## Графика
- зелено-чёрная графика имитирующая старый терминал
- TBD

## Документация архитектурных решений
- все важные архитектурные решения по подсистемам описываются в папке `docs/`
- каждая подсистема — отдельный файл (например `docs/transport.md`, `docs/serialization.md`, `docs/physics.md`)
- ссылки на эти файлы приведены ниже, чтобы Claude мог подгрузить нужный контекст в начале сессии
- при принятии нового архитектурного решения — обновить соответствующий doc-файл
